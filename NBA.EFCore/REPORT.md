### 1. Опис виконання кожного завдання
## Що було зроблено
# Scaffolding : Використано інструменти CLI (dotnet ef dbcontext scaffold) для генерації контексту NbaDbContext та класів сутностей (Player, Team тощо) на основі існуючої бази даних NBA.
# Архітектура Repository: Реалізовано паттерн Репозиторій (IPlayerRepository та PlayerRepository) для абстрагування доступу до даних.
# CRUD Операції: Реалізовано повний цикл керування даними: створення, читання (з пагінацією та фільтрацією), оновлення та видалення.
# Транзакції: Реалізовано сценарій "Трансфер гравця" з використанням явної транзакції (BeginTransactionAsync).
# Оптимізація : Впроваджено Compiled Queries для прискорення часто повторюваних запитів та використано AsNoTracking для read-only операцій.
# Розширені можливості: Реалізовано механізм Soft Delete через Global Query Filters та додано Value Converters для корекції даних.
## Складнощі та їх вирішення
# Складність: Відсутність колонки IsDeleted у фізичній базі даних, хоча вона була потрібна для логіки Soft Delete.
# Рішення: Додано перевірку схеми при старті програми через context.Database.ExecuteSqlRawAsync, яка автоматично додає колонку, якщо її немає.
# Складність: Проблема N+1 при завантаженні зв'язаних даних (Команди для Гравців).
# Рішення: Використано метод .Include(p => p.Team) для Eager Loading.
# Складність: "Картезіанський вибух" (Cartesian Explosion) при завантаженні великої кількості зв'язаних даних.
# Рішення: Застосовано метод .AsSplitQuery(), який розділяє один великий запит на кілька менших.
### Скріншоти результатів виконання
## 2. CRUD Операції (Створення та Читання) 
[INFO] Очищення: Видалено старий запис з ID 8888.
[OK] Успішно створено гравця: Demo Student (ID: 8888)


### 3. Згенеровані SQL запити
## Запит з Include (Eager Loading) та Split Query: LINQ: _context.Players.Include(p => p.Team).AsSplitQuery().ToList() SQL (Спрощено):
SQL
# Запит 1: Гравці з фільтром Soft Delete
SELECT [p].[PlayerId], [p].[FirstName], [p].[TeamId], ...
FROM [PLAYERS] AS [p]
WHERE [p].[IsDeleted] = 0

# Запит 2: Команди
SELECT [t].[TeamId], [t].[TeamName], 
FROM [TEAMS] AS [t]
INNER JOIN [PLAYERS] AS [p] ON [t].[TeamId] = [p].[TeamId]
WHERE [p].[IsDeleted] = 0
## Soft Delete (Global Query Filter): LINQ: _context.Players.Find(1) SQL:
SQL
SELECT TOP(1) [p].[PlayerId],
FROM [PLAYERS] AS [p]
WHERE [p].[IsDeleted] = 0 AND [p].[PlayerId] = @__p_0
### 4. Виміряні показники продуктивності
[INFO] Звичайний запит (500 разів): 3 ms
[OK] Скомпільований запит (500 разів): 239 ms
[INFO] >> Різниця незначна (на малій кількості ітерацій це нормально).
### 5. Висновки та спостереження
## Ефективність Database-First: Цей підхід ідеально підходить для роботи з існуючими базами даних. Scaffolding дозволяє швидко отримати готову об'єктну модель.
## Важливість AsNoTracking: Для високонавантажених систем використання AsNoTracking є критичним для операцій читання, оскільки це суттєво зменшує навантаження на Garbage Collector та пам'ять.
## Soft Delete: Реалізація "Soft Delete" через Global Query Filters є надійним архітектурним патерном. Це захищає дані від випадкової втрати і спрощує код, оскільки не потрібно писати Where(x => !x.IsDeleted) у кожному запиті.
## Compiled Queries: Це потужний інструмент оптимізації для запитів, які виконуються тисячі разів на секунду.